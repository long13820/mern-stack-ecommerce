{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _jsxFileName = \"D:\\\\GitHub\\\\mern-stack-ecommerce\\\\easy-shop\\\\node_modules\\\\native-base-shoutem-theme\\\\src\\\\connectStyle.js\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport hoistStatics from 'hoist-non-react-statics';\nimport * as _ from 'lodash';\nimport normalizeStyle from \"./StyleNormalizer/normalizeStyle\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport Theme, { ThemeShape } from \"./Theme\";\nimport { resolveComponentStyle } from \"./resolveComponentStyle\";\nvar themeCache = {};\nexport function clearThemeCache() {\n  themeCache = {};\n}\n\nfunction throwConnectStyleError(errorMessage, componentDisplayName) {\n  throw Error(errorMessage + \" - when connecting \" + componentDisplayName + \" component to style.\");\n}\n\nfunction getTheme(context) {\n  return context.theme || Theme.getDefaultTheme();\n}\n\nfunction isStyleVariant(propertyName) {\n  return /^\\./.test(propertyName);\n}\n\nfunction isChildStyle(propertyName) {\n  return /(^[^\\.].*\\.)|^\\*$/.test(propertyName);\n}\n\nfunction getConcreteStyle(style) {\n  return _.pickBy(style, function (value, key) {\n    return !isStyleVariant(key) && !isChildStyle(key);\n  });\n}\n\nexport default (function (componentStyleName) {\n  var componentStyle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var mapPropsToStyleNames = arguments.length > 2 ? arguments[2] : undefined;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  function getComponentDisplayName(WrappedComponent) {\n    return WrappedComponent.displayName || WrappedComponent.name || \"Component\";\n  }\n\n  return function wrapWithStyledComponent(WrappedComponent) {\n    var componentDisplayName = getComponentDisplayName(WrappedComponent);\n\n    if (!_.isPlainObject(componentStyle)) {\n      throwConnectStyleError(\"Component style must be plain object\", componentDisplayName);\n    }\n\n    if (!_.isString(componentStyleName)) {\n      throwConnectStyleError(\"Component Style Name must be string\", componentDisplayName);\n    }\n\n    var StyledComponent = function (_React$Component) {\n      _inherits(StyledComponent, _React$Component);\n\n      var _super = _createSuper(StyledComponent);\n\n      function StyledComponent(props, context) {\n        var _this;\n\n        _classCallCheck(this, StyledComponent);\n\n        _this = _super.call(this, props, context);\n\n        var styleNames = _this.getStyleNames(props);\n\n        var style = props.style;\n\n        var finalStyle = _this.getFinalStyle(props, context, style, styleNames);\n\n        _this.setWrappedInstance = _this.setWrappedInstance.bind(_assertThisInitialized(_this));\n        _this.resolveConnectedComponentStyle = _this.resolveConnectedComponentStyle.bind(_assertThisInitialized(_this));\n        _this.state = {\n          style: finalStyle,\n          addedProps: _this.resolveAddedProps(),\n          styleNames: styleNames\n        };\n        return _this;\n      }\n\n      _createClass(StyledComponent, [{\n        key: \"getFinalStyle\",\n        value: function getFinalStyle(props, context, style, styleNames) {\n          var resolvedStyle = {};\n\n          if (context.parentPath) {\n            resolvedStyle = this.getOrSetStylesInCache(context, props, styleNames, [].concat(_toConsumableArray(context.parentPath), [componentStyleName], _toConsumableArray(styleNames)));\n          } else {\n            resolvedStyle = this.resolveStyle(context, props, styleNames);\n            themeCache[componentStyleName] = resolvedStyle;\n          }\n\n          var concreteStyle = getConcreteStyle(_.merge({}, resolvedStyle));\n\n          if (_.isArray(style)) {\n            return [concreteStyle].concat(_toConsumableArray(style));\n          }\n\n          if (typeof style == \"number\" || typeof style == \"object\") {\n            return [concreteStyle, style];\n          }\n\n          return concreteStyle;\n        }\n      }, {\n        key: \"getStyleNames\",\n        value: function getStyleNames(props) {\n          var styleNamesArr = _.map(props, function (value, key) {\n            if (typeof value !== \"object\" && value === true) {\n              return \".\" + key;\n            } else {\n              return false;\n            }\n          });\n\n          _.remove(styleNamesArr, function (value, index) {\n            return value === false;\n          });\n\n          return styleNamesArr;\n        }\n      }, {\n        key: \"getParentPath\",\n        value: function getParentPath() {\n          if (!this.context.parentPath) {\n            return [componentStyleName];\n          } else {\n            return [].concat(_toConsumableArray(this.context.parentPath), [componentStyleName], _toConsumableArray(this.getStyleNames(this.props)));\n          }\n        }\n      }, {\n        key: \"getChildContext\",\n        value: function getChildContext() {\n          return {\n            parentPath: this.getParentPath()\n          };\n        }\n      }, {\n        key: \"UNSAFE_componentWillReceiveProps\",\n        value: function UNSAFE_componentWillReceiveProps(nextProps, nextContext) {\n          var styleNames = this.getStyleNames(nextProps);\n          var style = nextProps.style;\n\n          if (this.shouldRebuildStyle(nextProps, nextContext, styleNames)) {\n            var finalStyle = this.getFinalStyle(nextProps, nextContext, style, styleNames);\n            this.setState({\n              style: finalStyle,\n              styleNames: styleNames\n            });\n          }\n        }\n      }, {\n        key: \"setNativeProps\",\n        value: function setNativeProps(nativeProps) {\n          if (this.wrappedInstance.setNativeProps) {\n            this.wrappedInstance.setNativeProps(nativeProps);\n          }\n        }\n      }, {\n        key: \"setWrappedInstance\",\n        value: function setWrappedInstance(component) {\n          if (component && component._root) {\n            this._root = component._root;\n          } else {\n            this._root = component;\n          }\n\n          this.wrappedInstance = this._root;\n        }\n      }, {\n        key: \"hasStyleNameChanged\",\n        value: function hasStyleNameChanged(nextProps, styleNames) {\n          return mapPropsToStyleNames && this.props !== nextProps && !_.isEqual(this.state.styleNames, styleNames);\n        }\n      }, {\n        key: \"shouldRebuildStyle\",\n        value: function shouldRebuildStyle(nextProps, nextContext, styleNames) {\n          return nextProps.style !== this.props.style || nextProps.styleName !== this.props.styleName || nextContext.theme !== this.context.theme || !_.isEqual(nextContext.parentPath, this.context.parentPath) || this.hasStyleNameChanged(nextProps, styleNames);\n        }\n      }, {\n        key: \"resolveStyleNames\",\n        value: function resolveStyleNames(props) {\n          var styleName = props.styleName;\n          var styleNames = styleName ? styleName.split(/\\s/g) : [];\n\n          if (!mapPropsToStyleNames) {\n            return styleNames;\n          }\n\n          return _.uniq(mapPropsToStyleNames(styleNames, props));\n        }\n      }, {\n        key: \"resolveAddedProps\",\n        value: function resolveAddedProps() {\n          var addedProps = {};\n\n          if (options.withRef) {\n            addedProps.ref = \"wrappedInstance\";\n          }\n\n          return addedProps;\n        }\n      }, {\n        key: \"getOrSetStylesInCache\",\n        value: function getOrSetStylesInCache(context, props, styleNames, path) {\n          if (themeCache && themeCache[path.join(\">\")]) {\n            return themeCache[path.join(\">\")];\n          } else {\n            var resolvedStyle = this.resolveStyle(context, props, styleNames);\n\n            if (Object.keys(themeCache).length < 10000) {\n              themeCache[path.join(\">\")] = resolvedStyle;\n            }\n\n            return resolvedStyle;\n          }\n        }\n      }, {\n        key: \"resolveStyle\",\n        value: function resolveStyle(context, props, styleNames) {\n          var parentStyle = {};\n          var theme = getTheme(context);\n          var themeStyle = theme.createComponentStyle(componentStyleName, componentStyle);\n\n          if (context.parentPath) {\n            parentStyle = themeCache[context.parentPath.join(\">\")];\n          } else {\n            parentStyle = resolveComponentStyle(componentStyleName, styleNames, themeStyle, parentStyle);\n          }\n\n          return resolveComponentStyle(componentStyleName, styleNames, themeStyle, parentStyle);\n        }\n      }, {\n        key: \"resolveConnectedComponentStyle\",\n        value: function resolveConnectedComponentStyle(props) {\n          var styleNames = this.resolveStyleNames(props);\n          return this.resolveStyle(this.context, props, styleNames).componentStyle;\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var _this$state = this.state,\n              addedProps = _this$state.addedProps,\n              style = _this$state.style;\n          return React.createElement(WrappedComponent, _extends({}, this.props, addedProps, {\n            style: style,\n            ref: this.setWrappedInstance,\n            __self: this,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 392,\n              columnNumber: 11\n            }\n          }));\n        }\n      }]);\n\n      return StyledComponent;\n    }(React.Component);\n\n    StyledComponent.contextTypes = {\n      theme: ThemeShape,\n      parentPath: PropTypes.array\n    };\n    StyledComponent.childContextTypes = {\n      parentPath: PropTypes.array\n    };\n    StyledComponent.propTypes = {\n      style: PropTypes.oneOfType([PropTypes.object, PropTypes.number, PropTypes.array]),\n      styleName: PropTypes.string,\n      virtual: PropTypes.bool\n    };\n    StyledComponent.defaultProps = {\n      virtual: options.virtual\n    };\n    StyledComponent.displayName = \"Styled(\" + componentDisplayName + \")\";\n    StyledComponent.WrappedComponent = WrappedComponent;\n    return hoistStatics(StyledComponent, WrappedComponent);\n  };\n});","map":{"version":3,"names":["React","PropTypes","hoistStatics","_","normalizeStyle","Theme","ThemeShape","resolveComponentStyle","themeCache","clearThemeCache","throwConnectStyleError","errorMessage","componentDisplayName","Error","getTheme","context","theme","getDefaultTheme","isStyleVariant","propertyName","test","isChildStyle","getConcreteStyle","style","pickBy","value","key","componentStyleName","componentStyle","mapPropsToStyleNames","options","getComponentDisplayName","WrappedComponent","displayName","name","wrapWithStyledComponent","isPlainObject","isString","StyledComponent","props","styleNames","getStyleNames","finalStyle","getFinalStyle","setWrappedInstance","bind","resolveConnectedComponentStyle","state","addedProps","resolveAddedProps","resolvedStyle","parentPath","getOrSetStylesInCache","resolveStyle","concreteStyle","merge","isArray","styleNamesArr","map","remove","index","getParentPath","nextProps","nextContext","shouldRebuildStyle","setState","nativeProps","wrappedInstance","setNativeProps","component","_root","isEqual","styleName","hasStyleNameChanged","split","uniq","withRef","ref","path","join","Object","keys","length","parentStyle","themeStyle","createComponentStyle","resolveStyleNames","Component","contextTypes","array","childContextTypes","propTypes","oneOfType","object","number","string","virtual","bool","defaultProps"],"sources":["D:/GitHub/mern-stack-ecommerce/easy-shop/node_modules/native-base-shoutem-theme/src/connectStyle.js"],"sourcesContent":["import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport hoistStatics from 'hoist-non-react-statics';\r\nimport * as _ from 'lodash';\r\nimport normalizeStyle from './StyleNormalizer/normalizeStyle';\r\nimport { StyleSheet } from \"react-native\";\r\n\r\nimport Theme, { ThemeShape } from \"./Theme\";\r\nimport { resolveComponentStyle } from \"./resolveComponentStyle\";\r\n\r\nlet themeCache = {};\r\n\r\n/**\r\n * clear theme cache\r\n * @export\r\n */\r\nexport function clearThemeCache() {\r\n  themeCache = {};\r\n}\r\n\r\n/**\r\n * Formats and throws an error when connecting component style with the theme.\r\n *\r\n * @param errorMessage The error message.\r\n * @param componentDisplayName The name of the component that is being connected.\r\n */\r\nfunction throwConnectStyleError(errorMessage, componentDisplayName) {\r\n  throw Error(\r\n    `${errorMessage} - when connecting ${componentDisplayName} component to style.`\r\n  );\r\n}\r\n\r\n/**\r\n * Returns the theme object from the provided context,\r\n * or an empty theme if the context doesn't contain a theme.\r\n *\r\n * @param context The React component context.\r\n * @returns {Theme} The Theme object.\r\n */\r\nfunction getTheme(context) {\r\n  // Fallback to a default theme if the component isn't\r\n  // rendered in a StyleProvider.\r\n  return context.theme || Theme.getDefaultTheme();\r\n}\r\n\r\n/**\r\n * Matches any style properties that represent component style variants.\r\n * Those styles can be applied to the component by using the styleName\r\n * prop. All style variant property names must start with a single '.'\r\n * character, e.g., '.variant'.\r\n *\r\n * @param propertyName The style property name.\r\n * @returns {boolean} True if the style property represents a component variant, false otherwise.\r\n */\r\nfunction isStyleVariant(propertyName) {\r\n  return /^\\./.test(propertyName);\r\n}\r\n\r\n/**\r\n * Matches any style properties that represent style rules that target the\r\n * component children. Those styles can have two formats, they can either\r\n * target the components by component name ('shoutem.ui.Text'), or by component\r\n * name and variant ('shoutem.ui.Text.line-through'). Beside specifying the\r\n * component name, those styles can also target any component by using the\r\n * '*' wildcard ('*', or '*.line-through'). The rule to identify those styles is\r\n * that they have to contain a '.' character in their name or be a '*'.\r\n *\r\n * @param propertyName The style property name.\r\n * @returns {boolean} True if the style property represents a child style, false otherwise.\r\n */\r\nfunction isChildStyle(propertyName) {\r\n  return /(^[^\\.].*\\.)|^\\*$/.test(propertyName);\r\n}\r\n\r\nfunction getConcreteStyle(style) {\r\n  return _.pickBy(style, (value, key) => {\r\n    return !isStyleVariant(key) && !isChildStyle(key);\r\n  });\r\n}\r\n\r\n/**\r\n * Resolves the final component style by using the theme style, if available and\r\n * merging it with the style provided directly through the style prop, and style\r\n * variants applied through the styleName prop.\r\n *\r\n * @param componentStyleName The component name that will be used\r\n * to target this component in style rules.\r\n * @param componentStyle The default component style.\r\n * @param mapPropsToStyleNames Pure function to customize styleNames depending on props.\r\n * @param options The additional connectStyle options\r\n * @param options.virtual The default value of the virtual prop\r\n * @param options.withRef Create component ref with addedProps; if true, ref name is wrappedInstance\r\n * @returns {StyledComponent} The new component that will handle\r\n * the styling of the wrapped component.\r\n */\r\nexport default (\r\n  componentStyleName,\r\n  componentStyle = {},\r\n  mapPropsToStyleNames,\r\n  options = {}\r\n) => {\r\n  function getComponentDisplayName(WrappedComponent) {\r\n    return WrappedComponent.displayName || WrappedComponent.name || \"Component\";\r\n  }\r\n\r\n  return function wrapWithStyledComponent(WrappedComponent) {\r\n    const componentDisplayName = getComponentDisplayName(WrappedComponent);\r\n\r\n    if (!_.isPlainObject(componentStyle)) {\r\n      throwConnectStyleError(\r\n        \"Component style must be plain object\",\r\n        componentDisplayName\r\n      );\r\n    }\r\n\r\n    if (!_.isString(componentStyleName)) {\r\n      throwConnectStyleError(\r\n        \"Component Style Name must be string\",\r\n        componentDisplayName\r\n      );\r\n    }\r\n\r\n    class StyledComponent extends React.Component {\r\n      static contextTypes = {\r\n        theme: ThemeShape,\r\n        // The style inherited from the parent\r\n        // parentStyle: PropTypes.object,\r\n        parentPath: PropTypes.array\r\n      };\r\n\r\n      static childContextTypes = {\r\n        // Provide the parent style to child components\r\n        // parentStyle: PropTypes.object,\r\n        // resolveStyle: PropTypes.func,\r\n        parentPath: PropTypes.array\r\n      };\r\n\r\n      static propTypes = {\r\n        // Element style that overrides any other style of the component\r\n        style: PropTypes.oneOfType([\r\n          PropTypes.object,\r\n          PropTypes.number,\r\n          PropTypes.array\r\n        ]),\r\n        // The style variant names to apply to this component,\r\n        // multiple variants may be separated with a space character\r\n        styleName: PropTypes.string,\r\n        // Virtual elements will propagate the parent\r\n        // style to their children, i.e., the children\r\n        // will behave as they are placed directly below\r\n        // the parent of a virtual element.\r\n        virtual: PropTypes.bool\r\n      };\r\n\r\n      static defaultProps = {\r\n        virtual: options.virtual\r\n      };\r\n\r\n      static displayName = `Styled(${componentDisplayName})`;\r\n      static WrappedComponent = WrappedComponent;\r\n\r\n      constructor(props, context) {\r\n        super(props, context);\r\n        // console.log(context.parentPath);\r\n        const styleNames = this.getStyleNames(props);\r\n        const style = props.style;\r\n\r\n        const finalStyle = this.getFinalStyle(\r\n          props,\r\n          context,\r\n          style,\r\n          styleNames\r\n        );\r\n\r\n        this.setWrappedInstance = this.setWrappedInstance.bind(this);\r\n        this.resolveConnectedComponentStyle = this.resolveConnectedComponentStyle.bind(\r\n          this\r\n        );\r\n        this.state = {\r\n          style: finalStyle,\r\n          // AddedProps are additional WrappedComponent props\r\n          // Usually they are set trough alternative ways,\r\n          // such as theme style, or trough options\r\n          addedProps: this.resolveAddedProps(),\r\n          styleNames\r\n        };\r\n      }\r\n\r\n      getFinalStyle(props, context, style, styleNames) {\r\n        let resolvedStyle = {};\r\n        if (context.parentPath) {\r\n          resolvedStyle = this.getOrSetStylesInCache(\r\n            context,\r\n            props,\r\n            styleNames,\r\n            [...context.parentPath, componentStyleName, ...styleNames]\r\n          );\r\n        } else {\r\n          resolvedStyle = this.resolveStyle(context, props, styleNames);\r\n          themeCache[componentStyleName] = resolvedStyle;\r\n        }\r\n\r\n        const concreteStyle = getConcreteStyle(_.merge({}, resolvedStyle));\r\n\r\n        if (_.isArray(style)) {\r\n          return [concreteStyle, ...style];\r\n        }\r\n\r\n        if (typeof style == \"number\" || typeof style == \"object\") {\r\n          return [concreteStyle, style];\r\n        }\r\n\r\n        return concreteStyle;\r\n      }\r\n\r\n      getStyleNames(props) {\r\n        const styleNamesArr = _.map(props, (value, key) => {\r\n          if (typeof value !== \"object\" && value === true) {\r\n            return \".\" + key;\r\n          } else {\r\n            return false;\r\n          }\r\n        });\r\n        _.remove(styleNamesArr, (value, index) => {\r\n          return value === false;\r\n        });\r\n\r\n        return styleNamesArr;\r\n      }\r\n\r\n      getParentPath() {\r\n        if (!this.context.parentPath) {\r\n          return [componentStyleName];\r\n        } else {\r\n          return [\r\n            ...this.context.parentPath,\r\n            componentStyleName,\r\n            ...this.getStyleNames(this.props)\r\n          ];\r\n        }\r\n      }\r\n\r\n      getChildContext() {\r\n        return {\r\n          // parentStyle: this.props.virtual ?\r\n          //   this.context.parentStyle :\r\n          //   this.state.childrenStyle,\r\n          // resolveStyle: this.resolveConnectedComponentStyle,\r\n          parentPath: this.getParentPath()\r\n        };\r\n      }\r\n\r\n      UNSAFE_componentWillReceiveProps(nextProps, nextContext) {\r\n        const styleNames = this.getStyleNames(nextProps);\r\n        const style = nextProps.style;\r\n        if (this.shouldRebuildStyle(nextProps, nextContext, styleNames)) {\r\n          const finalStyle = this.getFinalStyle(\r\n            nextProps,\r\n            nextContext,\r\n            style,\r\n            styleNames\r\n          );\r\n\r\n          this.setState({\r\n            style: finalStyle,\r\n            // childrenStyle: resolvedStyle.childrenStyle,\r\n            styleNames\r\n          });\r\n        }\r\n      }\r\n\r\n      setNativeProps(nativeProps) {\r\n        if (this.wrappedInstance.setNativeProps) {\r\n          this.wrappedInstance.setNativeProps(nativeProps);\r\n        }\r\n      }\r\n\r\n      setWrappedInstance(component) {\r\n        if (component && component._root) {\r\n          this._root = component._root;\r\n        } else {\r\n          this._root = component;\r\n        }\r\n        this.wrappedInstance = this._root;\r\n      }\r\n\r\n      hasStyleNameChanged(nextProps, styleNames) {\r\n        return (\r\n          mapPropsToStyleNames &&\r\n          this.props !== nextProps &&\r\n          // Even though props did change here,\r\n          // it doesn't necessary means changed props are those which affect styleName\r\n          !_.isEqual(this.state.styleNames, styleNames)\r\n        );\r\n      }\r\n\r\n      shouldRebuildStyle(nextProps, nextContext, styleNames) {\r\n        return (\r\n          nextProps.style !== this.props.style ||\r\n          nextProps.styleName !== this.props.styleName ||\r\n          nextContext.theme !== this.context.theme ||\r\n          !_.isEqual(nextContext.parentPath, this.context.parentPath) ||\r\n          this.hasStyleNameChanged(nextProps, styleNames)\r\n        );\r\n      }\r\n\r\n      resolveStyleNames(props) {\r\n        const { styleName } = props;\r\n        const styleNames = styleName ? styleName.split(/\\s/g) : [];\r\n\r\n        if (!mapPropsToStyleNames) {\r\n          return styleNames;\r\n        }\r\n\r\n        // We only want to keep the unique style names\r\n        return _.uniq(mapPropsToStyleNames(styleNames, props));\r\n      }\r\n\r\n      resolveAddedProps() {\r\n        const addedProps = {};\r\n        if (options.withRef) {\r\n          addedProps.ref = \"wrappedInstance\";\r\n        }\r\n        return addedProps;\r\n      }\r\n\r\n      getOrSetStylesInCache(context, props, styleNames, path) {\r\n        if (themeCache && themeCache[path.join(\">\")]) {\r\n          // console.log('**************');\r\n\r\n          return themeCache[path.join(\">\")];\r\n        } else {\r\n          const resolvedStyle = this.resolveStyle(context, props, styleNames);\r\n          if (Object.keys(themeCache).length < 10000) {\r\n            themeCache[path.join(\">\")] = resolvedStyle;\r\n          }\r\n          return resolvedStyle;\r\n        }\r\n      }\r\n\r\n      resolveStyle(context, props, styleNames) {\r\n        let parentStyle = {};\r\n\r\n        const theme = getTheme(context);\r\n        const themeStyle = theme.createComponentStyle(\r\n          componentStyleName,\r\n          componentStyle\r\n        );\r\n\r\n        if (context.parentPath) {\r\n          parentStyle = themeCache[context.parentPath.join(\">\")];\r\n        } else {\r\n          parentStyle = resolveComponentStyle(\r\n            componentStyleName,\r\n            styleNames,\r\n            themeStyle,\r\n            parentStyle\r\n          );\r\n        }\r\n\r\n        return resolveComponentStyle(\r\n          componentStyleName,\r\n          styleNames,\r\n          themeStyle,\r\n          parentStyle\r\n        );\r\n      }\r\n\r\n      /**\r\n       * A helper function provided to child components that enables\r\n       * them to resolve their style for any set of prop values.\r\n       *\r\n       * @param props The component props to use to resolve the style values.\r\n       * @returns {*} The resolved component style.\r\n       */\r\n      resolveConnectedComponentStyle(props) {\r\n        const styleNames = this.resolveStyleNames(props);\r\n        return this.resolveStyle(this.context, props, styleNames)\r\n          .componentStyle;\r\n      }\r\n\r\n      render() {\r\n        // console.log('themeCache', themeCache);\r\n\r\n        // if(componentStyleName == 'NativeBase.Text') {\r\n        //   console.log(this.state.style);\r\n        //   console.log(themeCache);\r\n        // }\r\n\r\n        const { addedProps, style } = this.state;\r\n        return (\r\n          <WrappedComponent\r\n            {...this.props}\r\n            {...addedProps}\r\n            style={style}\r\n            ref={this.setWrappedInstance}\r\n          />\r\n        );\r\n      }\r\n    }\r\n\r\n    return hoistStatics(StyledComponent, WrappedComponent);\r\n  };\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}